---
// Admin Bracket - Tournament Bracket Editor
// Uses shared Bracket component with admin editing enabled
import AdminLayout from '../../components/admin/AdminLayout.astro';
import Bracket from '../../components/Bracket.astro';
---

<AdminLayout title="Bracket" activeNav="bracket">
  <div class="bracket-page">
    <!-- Header Actions -->
    <div class="page-actions">
      <div class="bracket-status">
        <span id="bracketStatus">Loading...</span>
      </div>
      <div class="action-buttons">
        <button class="btn btn--secondary btn-slam" id="assignTeamsBtn">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 18px; height: 18px;">
            <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2" />
            <circle cx="8.5" cy="7" r="4" />
            <polyline points="17 11 19 13 23 9" />
          </svg>
          Auto-Assign
        </button>
        <button class="btn btn--secondary btn-slam" id="resetBracketBtn">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 18px; height: 18px;">
            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
            <path d="M3 3v5h5" />
          </svg>
          Reset
        </button>
      </div>
    </div>

    <!-- Bracket Component (Admin Mode) -->
    <Bracket isAdmin={true} />
  </div>

  <!-- Reset Confirmation Modal -->
  <div class="modal-backdrop" id="resetModal">
    <div class="modal modal--sm">
      <div class="modal__header">
        <h2 class="modal__title">Reset Bracket</h2>
      </div>
      <div class="modal__body">
        <p>Are you sure you want to reset the entire bracket?</p>
        <p class="warning-text">All match results will be cleared. This cannot be undone.</p>
      </div>
      <div class="modal__actions">
        <button type="button" class="btn btn--secondary" id="cancelReset">Cancel</button>
        <button type="button" class="btn btn--danger" id="confirmReset">Reset Bracket</button>
      </div>
    </div>
  </div>
</AdminLayout>

<style>
  .bracket-page {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .page-actions {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .bracket-status {
    font-size: 0.8rem;
    color: rgba(255, 255, 255, 0.5);
    text-align: center;
  }

  .action-buttons {
    display: flex;
    gap: 8px;
    justify-content: center;
  }

  .action-buttons .btn {
    flex: 1;
    max-width: 160px;
    justify-content: center;
    padding: 10px 16px;
    font-size: 0.75rem;
  }

  .action-buttons .btn svg {
    width: 16px;
    height: 16px;
  }

  /* Modal Styles */
  .modal-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
    display: flex;
    align-items: flex-end;
    justify-content: center;
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease;
  }

  .modal-backdrop.open {
    opacity: 1;
    visibility: visible;
  }

  .modal {
    background: var(--bg-card);
    border: 1px solid var(--border-subtle);
    border-radius: 20px 20px 0 0;
    width: 100%;
    transform: translateY(100%);
    transition: transform 0.3s ease;
  }

  .modal-backdrop.open .modal {
    transform: translateY(0);
  }

  .modal--sm {
    max-height: 50vh;
  }

  .modal__header {
    padding: 20px;
    border-bottom: 1px solid var(--border-subtle);
  }

  .modal__title {
    font-family: "Bodoni Moda", serif;
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--brass);
  }

  .modal__body {
    padding: 20px;
    padding-bottom: max(20px, env(safe-area-inset-bottom));
  }

  .modal__actions {
    display: flex;
    flex-direction: column;
    gap: 10px;
    padding-top: 16px;
    border-top: 1px solid var(--border-subtle);
    margin-top: 8px;
  }

  .modal__actions .btn {
    width: 100%;
    justify-content: center;
    padding: 14px 20px;
    font-size: 1rem;
  }

  .warning-text {
    color: #e57373;
    font-size: 0.85rem;
    margin-top: 8px;
  }

  /* Desktop overrides */
  @media (min-width: 769px) {
    .bracket-page {
      gap: 24px;
    }

    .page-actions {
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
    }

    .bracket-status {
      font-size: 0.9rem;
      text-align: left;
    }

    .action-buttons {
      gap: 12px;
      justify-content: flex-end;
    }

    .action-buttons .btn {
      flex: none;
      max-width: none;
    }

    /* Modal - centered on desktop */
    .modal-backdrop {
      align-items: center;
    }

    .modal {
      border-radius: 16px;
      max-width: 400px;
      transform: translateY(20px);
    }

    .modal--sm {
      max-width: 380px;
      max-height: 90vh;
    }

    .modal__actions {
      flex-direction: row;
      justify-content: flex-end;
    }

    .modal__actions .btn {
      width: auto;
      padding: 10px 20px;
      font-size: 0.85rem;
    }
  }
</style>

<script>
  // Admin Bracket Controller - 4-Team Finals
  // Finals bracket: 2 Semifinals (Round 1) + 1 Championship (Round 2)
  let teams = [];
  let matches = [];

  window.addEventListener('adminReady', async ({ detail: { supabase } }) => {
    await loadData(supabase);
    setupEventListeners(supabase);
    setupRealtimeSubscription(supabase);
  });

  async function loadData(supabase) {
    const [teamsRes, matchesRes] = await Promise.all([
      supabase.from('teams').select('*').order('seed'),
      // Only load finals matches (phase = 'finals')
      supabase.from('matches').select('*').eq('phase', 'finals').order('round').order('match_number')
    ]);

    teams = teamsRes.data || [];
    matches = matchesRes.data || [];
    renderBracket();
    updateStatus();
  }

  function renderBracket() {
    // Update all match cards (both mobile and desktop)
    // Finals: Round 1 = Semis, Round 2 = Championship
    matches.forEach(match => {
      // Find all match elements for this round/match (mobile + desktop)
      const matchEls = document.querySelectorAll(`[data-round="${match.round}"][data-match="${match.match_number}"]`);

      matchEls.forEach(matchEl => {
        const team1 = teams.find(t => t.id === match.team1_id);
        const team2 = teams.find(t => t.id === match.team2_id);
        const winner = match.winner_id ? teams.find(t => t.id === match.winner_id) : null;

        // Update team names
        const team1NameEl = matchEl.querySelector('[data-team1-name]');
        const team2NameEl = matchEl.querySelector('[data-team2-name]');

        if (team1) {
          team1NameEl.textContent = team1.name;
        } else if (match.round === 1) {
          // Semifinals - show seed position
          team1NameEl.textContent = match.match_number === 1 ? 'Seed #1' : 'Seed #2';
        } else {
          // Championship
          team1NameEl.textContent = 'Winner Semi 1';
        }

        if (team2) {
          team2NameEl.textContent = team2.name;
        } else if (match.round === 1) {
          // Semifinals - show seed position
          team2NameEl.textContent = match.match_number === 1 ? 'Seed #4' : 'Seed #3';
        } else {
          // Championship
          team2NameEl.textContent = 'Winner Semi 2';
        }

        // Update scores (inputs for admin)
        const score1El = matchEl.querySelector('[data-team1-score]');
        const score2El = matchEl.querySelector('[data-team2-score]');

        if (score1El) {
          if (score1El.tagName === 'INPUT') {
            score1El.value = match.team1_score ?? '';
          } else {
            score1El.textContent = match.team1_score ?? '-';
          }
        }

        if (score2El) {
          if (score2El.tagName === 'INPUT') {
            score2El.value = match.team2_score ?? '';
          } else {
            score2El.textContent = match.team2_score ?? '-';
          }
        }

        // Highlight winner
        const teamRows = matchEl.querySelectorAll('[data-team-row]');
        teamRows.forEach(row => row.classList.remove('winner'));

        if (winner) {
          if (match.team1_id === winner.id) {
            teamRows[0]?.classList.add('winner');
          } else {
            teamRows[1]?.classList.add('winner');
          }
        }

        // Update status indicator
        const statusEl = matchEl.querySelector('[data-status-indicator]');
        if (statusEl) {
          statusEl.setAttribute('data-status', match.status);
          const statusLabels = {
            'pending': 'Pending',
            'in_progress': 'In Progress',
            'completed': 'Completed'
          };
          statusEl.setAttribute('data-tooltip', statusLabels[match.status] || match.status);
        }
      });
    });

    // Update champion display (both mobile and desktop)
    // Championship is now Round 2 (not Round 3)
    const finalMatch = matches.find(m => m.round === 2 && m.match_number === 1);
    const championEls = document.querySelectorAll('[data-champion-name], [data-desktop-champion-name]');

    championEls.forEach(el => {
      if (finalMatch && finalMatch.winner_id) {
        const champion = teams.find(t => t.id === finalMatch.winner_id);
        el.textContent = champion ? champion.name : 'TBD';
        el.classList.add('has-champion');
      } else {
        el.textContent = 'TBD';
        el.classList.remove('has-champion');
      }
    });
  }

  function updateStatus() {
    const statusEl = document.getElementById('bracketStatus');
    const completed = matches.filter(m => m.status === 'completed').length;
    const teamsInBracket = new Set([
      ...matches.map(m => m.team1_id).filter(Boolean),
      ...matches.map(m => m.team2_id).filter(Boolean)
    ]).size;

    if (teamsInBracket < 4) {
      statusEl.textContent = `${teamsInBracket}/4 teams seeded | ${completed}/3 matches`;
    } else {
      statusEl.textContent = `Finals ready | ${completed}/3 matches`;
    }
  }

  function setupEventListeners(supabase) {
    // Auto-assign redirects to Round Robin for seeding
    document.getElementById('assignTeamsBtn').addEventListener('click', async () => {
      // Check if round robin has at least 4 teams with standings
      try {
        const { data: standings } = await supabase.from('standings').select('*');

        if (!standings || standings.length < 4) {
          if (window.showToast) {
            window.showToast('Complete Round Robin first to seed finals', 'default');
          }
          // Redirect to round robin
          setTimeout(() => {
            window.location.href = '/admin/round-robin';
          }, 1500);
          return;
        }

        // Call seed finals function
        const { error } = await supabase.rpc('seed_finals_from_standings');

        if (error) throw error;

        await loadData(supabase);
        if (window.showToast) {
          window.showToast('Top 4 teams seeded into Finals!', 'success');
        }
      } catch (err) {
        console.error('Seed finals error:', err);
        if (window.showToast) {
          window.showToast(err.message || 'Failed to seed finals', 'default');
        }
      }
    });

    // Save match scores - works for all save buttons (mobile + desktop)
    document.querySelectorAll('[data-save-btn]').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        const matchEl = e.target.closest('[data-match]');
        const round = parseInt(matchEl.dataset.round);
        const matchNumber = parseInt(matchEl.dataset.match);

        const score1Input = matchEl.querySelector('[data-team1-score]');
        const score2Input = matchEl.querySelector('[data-team2-score]');

        const score1 = parseInt(score1Input?.value) || 0;
        const score2 = parseInt(score2Input?.value) || 0;

        const match = matches.find(m => m.round === round && m.match_number === matchNumber);
        if (!match) return;

        // Add saving state for The Slam animation
        const card = matchEl.closest('.match-card') || matchEl;
        card.classList.add('saving');
        btn.classList.add('saving');

        // Determine winner (higher score wins, must have both teams)
        let winnerId = null;
        let status = 'pending';

        if (match.team1_id && match.team2_id) {
          if (score1 > 0 || score2 > 0) {
            status = 'in_progress';
          }
          if (score1 > 0 && score2 > 0 && score1 !== score2) {
            winnerId = score1 > score2 ? match.team1_id : match.team2_id;
            status = 'completed';
          }
        }

        try {
          // Update this match
          await supabase.from('matches').update({
            team1_score: score1,
            team2_score: score2,
            winner_id: winnerId,
            status,
            completed_at: status === 'completed' ? new Date().toISOString() : null
          }).eq('id', match.id);

          // If completed, advance winner to next round (Semi -> Final)
          if (winnerId && round === 1) {
            await advanceWinner(supabase, round, matchNumber, winnerId);

            // Show winner toast and advance animation
            const winnerTeam = teams.find(t => t.id === winnerId);
            if (winnerTeam && window.showToast) {
              window.showToast(`${winnerTeam.name} advances to the Championship!`, 'success');
            }

            // Add advance animation
            const winnerRow = matchEl.querySelector(
              match.team1_id === winnerId ? '[data-team-row="1"]' : '[data-team-row="2"]'
            );
            if (winnerRow) {
              winnerRow.classList.add('advancing');
              setTimeout(() => winnerRow.classList.remove('advancing'), 600);
            }
          } else if (winnerId && round === 2) {
            // Championship won!
            const winnerTeam = teams.find(t => t.id === winnerId);
            if (winnerTeam && window.showToast) {
              window.showToast(`${winnerTeam.name} wins the championship!`, 'success', 5000);
            }
          }

          await loadData(supabase);

          // Champion reveal animation
          if (winnerId && round === 2) {
            const championEls = document.querySelectorAll('[data-champion-name], [data-desktop-champion-name]');
            championEls.forEach(el => {
              el.classList.add('revealing');
              setTimeout(() => el.classList.remove('revealing'), 800);
            });
          }
        } catch (err) {
          console.error('Save scores error:', err);
          if (window.showToast) {
            window.showToast('Failed to save scores', 'default');
          }
        } finally {
          // Remove saving state
          setTimeout(() => {
            card.classList.remove('saving');
            btn.classList.remove('saving');
          }, 150);
        }
      });
    });

    // Advance winner to Championship (Semi -> Final)
    async function advanceWinner(supabase, currentRound, currentMatchNumber, winnerId) {
      // Semi 1 winner -> Final team1, Semi 2 winner -> Final team2
      const position = currentMatchNumber === 1 ? 'team1_id' : 'team2_id';
      const finalMatch = matches.find(m => m.round === 2 && m.match_number === 1);

      if (finalMatch) {
        await supabase.from('matches').update({ [position]: winnerId }).eq('id', finalMatch.id);
      }
    }

    // Reset bracket modal
    const resetModal = document.getElementById('resetModal');
    document.getElementById('resetBracketBtn').addEventListener('click', () => {
      resetModal.classList.add('open');
    });

    document.getElementById('cancelReset').addEventListener('click', () => {
      resetModal.classList.remove('open');
    });

    resetModal.addEventListener('click', (e) => {
      if (e.target === resetModal) resetModal.classList.remove('open');
    });

    document.getElementById('confirmReset').addEventListener('click', async () => {
      try {
        // Reset all matches
        for (const match of matches) {
          await supabase.from('matches').update({
            team1_id: null,
            team2_id: null,
            team1_score: 0,
            team2_score: 0,
            winner_id: null,
            status: 'pending',
            completed_at: null
          }).eq('id', match.id);
        }

        resetModal.classList.remove('open');
        await loadData(supabase);
        if (window.showToast) {
          window.showToast('Bracket has been reset', 'success');
        }
      } catch (err) {
        console.error('Reset error:', err);
        if (window.showToast) {
          window.showToast('Failed to reset bracket', 'default');
        }
      }
    });
  }

  // Realtime subscription for live updates
  function setupRealtimeSubscription(supabase) {
    supabase
      .channel('admin-bracket-changes')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'matches' }, () => {
        loadData(supabase);
      })
      .on('postgres_changes', { event: '*', schema: 'public', table: 'teams' }, () => {
        loadData(supabase);
      })
      .subscribe();
  }
</script>
